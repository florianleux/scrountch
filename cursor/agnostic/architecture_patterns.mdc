# Architecture Patterns & Design Decisions

_Universal Flutter/Dart architectural patterns for any application_

## 1. OVERALL ARCHITECTURE

### Layered Architecture Pattern

**Priority**: High
**Applicability**: All Flutter applications
**Benefits**: Clear separation of concerns, testability, maintainability

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Presentation Layer         â”‚
â”‚  (screens/, widgets/, theme/)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Business Logic Layer       â”‚
â”‚         (services/)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Data Layer                â”‚
â”‚    (models/, repositories/)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Template**:

```dart
// Presentation Layer - UI components
class FeatureScreen extends StatefulWidget {
  // UI logic only, delegates to service layer
  void _handleUserAction() async {
    final result = await _featureService.performAction();
    // Handle UI response
  }
}

// Business Logic Layer - Services
class FeatureService {
  final ApiRepository _apiRepository;

  FeatureService(this._apiRepository);

  Future<Result> performAction() async {
    // Business rules and orchestration
    final data = await _apiRepository.fetchData();
    return _processBusinessLogic(data);
  }
}

// Data Layer - Models and Repositories
class ApiRepository {
  final ApiClient _apiClient;

  Future<List<DataModel>> fetchData() async {
    final response = await _apiClient.get('/endpoint');
    return response.map((json) => DataModel.fromJson(json)).toList();
  }
}

class DataModel {
  final String id;
  final String name;

  DataModel({required this.id, required this.name});

  factory DataModel.fromJson(Map<String, dynamic> json) {
    return DataModel(
      id: json['id'],
      name: json['name'],
    );
  }
}
```

## 2. SERVICE LAYER PATTERNS

### Decision Tree: Choosing Service Patterns

```
What type of service are you implementing?

â”œâ”€â”€ External Integration (APIs, Databases, Device Hardware)
â”‚   â”œâ”€â”€ Needs persistent connection/state?
â”‚   â”‚   â””â”€â”€ âœ… SINGLETON SERVICE PATTERN
â”‚   â”‚       â”œâ”€â”€ Examples: ApiService, DatabaseService, AuthService
â”‚   â”‚       â”œâ”€â”€ Benefits: Shared state, connection pooling
â”‚   â”‚       â””â”€â”€ Trade-offs: Global state, harder testing
â”‚   â””â”€â”€ Stateless operations only?
â”‚       â””â”€â”€ âœ… STATIC UTILITY SERVICE PATTERN
â”‚           â”œâ”€â”€ Examples: ValidationService, FormatterService
â”‚           â”œâ”€â”€ Benefits: Simple, testable, no state
â”‚           â””â”€â”€ Trade-offs: No shared resources
â”‚
â”œâ”€â”€ Business Logic Processing
â”‚   â”œâ”€â”€ Complex workflows with state?
â”‚   â”‚   â””â”€â”€ âœ… SINGLETON SERVICE PATTERN
â”‚   â”‚       â”œâ”€â”€ Examples: WorkflowService, ProcessingService
â”‚   â”‚       â””â”€â”€ Benefits: State management, process coordination
â”‚   â””â”€â”€ Pure business calculations?
â”‚       â””â”€â”€ âœ… STATIC UTILITY SERVICE PATTERN
â”‚           â”œâ”€â”€ Examples: CalculationService, ValidationService
â”‚           â””â”€â”€ Benefits: Predictable, easy testing
â”‚
â””â”€â”€ Utility Functions (Formatting, Validation, Calculations)
    â””â”€â”€ âœ… STATIC UTILITY SERVICE PATTERN (Always)
        â”œâ”€â”€ Examples: DateUtils, StringUtils, MathUtils
        â”œâ”€â”€ Benefits: No state, pure functions, easy testing
        â””â”€â”€ Trade-offs: None (recommended pattern)
```

### Singleton Service Pattern

**Priority**: High
**Use Case**: Stateful external integrations (APIs, databases, device services)

**Template**:

```dart
class ExternalService {
  static final ExternalService _instance = ExternalService._internal();
  factory ExternalService() => _instance;
  ExternalService._internal();

  // Service state
  bool _isInitialized = false;
  final ApiClient _apiClient = ApiClient();

  Future<void> initialize() async {
    if (!_isInitialized) {
      await _apiClient.configure();
      _isInitialized = true;
    }
  }

  Future<Result> performOperation() async {
    await initialize();
    return await _apiClient.request();
  }
}
```

**When to use**:

- External API services
- Database connections
- Device hardware access
- Authentication services

### Static Utility Service Pattern

**Priority**: High
**Use Case**: Stateless operations, pure functions

**Template**:

```dart
class UtilityService {
  // No constructor - pure static utility

  static String formatCurrency(double amount, {String currency = 'USD'}) {
    return NumberFormat.currency(symbol: currency).format(amount);
  }

  static DateTime parseDate(String dateString) {
    return DateTime.parse(dateString);
  }

  static bool validateEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }
}

class FileService {
  static Future<File?> pickFile({List<String>? allowedExtensions}) async {
    final result = await FilePicker.platform.pickFiles(
      type: allowedExtensions != null ? FileType.custom : FileType.any,
      allowedExtensions: allowedExtensions,
    );

    return result?.files.single.path != null
        ? File(result!.files.single.path!)
        : null;
  }

  static Future<String> readFileContent(File file) async {
    return await file.readAsString();
  }
}
```

**When to use**:

- File operations
- Data formatting/validation
- Calculations
- String manipulations

## 3. STATE MANAGEMENT STRATEGIES

### Decision Tree: Choosing State Management

```
Start Here: What type of application are you building?

â”œâ”€â”€ Simple App (1-5 screens, personal/family use)
â”‚   â””â”€â”€ âœ… LOCAL STATE + SERVICE LAYER
â”‚       â”œâ”€â”€ Complexity: Low
â”‚       â”œâ”€â”€ Learning Curve: Minimal
â”‚       â””â”€â”€ Maintenance: Easy
â”‚
â”œâ”€â”€ Medium App (5-15 screens, shared state needs)
â”‚   â”œâ”€â”€ Team Size < 3 developers?
â”‚   â”‚   â””â”€â”€ âœ… PROVIDER PATTERN
â”‚   â”‚       â”œâ”€â”€ Complexity: Medium
â”‚   â”‚       â”œâ”€â”€ Learning Curve: Moderate
â”‚   â”‚       â””â”€â”€ Maintenance: Good
â”‚   â””â”€â”€ Team Size >= 3 developers?
â”‚       â””â”€â”€ âœ… RIVERPOD PATTERN
â”‚           â”œâ”€â”€ Complexity: High
â”‚           â”œâ”€â”€ Learning Curve: Steep
â”‚           â””â”€â”€ Maintenance: Excellent
â”‚
â””â”€â”€ Large App (15+ screens, complex business logic)
    â””â”€â”€ âœ… RIVERPOD PATTERN (Required)
        â”œâ”€â”€ Complexity: High
        â”œâ”€â”€ Learning Curve: Steep
        â”œâ”€â”€ Maintenance: Excellent
        â””â”€â”€ Testing: Superior
```

### Local State + Service Layer (Recommended for Small-Medium Apps)

**Priority**: High
**Complexity**: Low
**Best for**: Simple apps, prototypes, family/personal apps

```dart
class _ScreenState extends State<Screen> {
  // Local UI state
  bool _isLoading = false;
  String? _errorMessage;
  List<DataModel> _items = [];

  // Service dependencies
  final DataService _dataService = DataService();

  Future<void> _loadData() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final items = await _dataService.fetchItems();
      setState(() {
        _items = items;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }
}
```

### Provider Pattern (Recommended for Medium Apps)

**Priority**: Medium
**Complexity**: Medium
**Best for**: Apps with shared state, user sessions, shopping carts

```dart
// State model
class UserState extends ChangeNotifier {
  User? _currentUser;
  bool _isLoading = false;

  User? get currentUser => _currentUser;
  bool get isLoading => _isLoading;
  bool get isLoggedIn => _currentUser != null;

  Future<void> login(String email, String password) async {
    _isLoading = true;
    notifyListeners();

    try {
      _currentUser = await AuthService().login(email, password);
    } catch (e) {
      _currentUser = null;
      rethrow;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  void logout() {
    _currentUser = null;
    notifyListeners();
  }
}

// App setup
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => UserState()),
        ChangeNotifierProvider(create: (_) => CartState()),
      ],
      child: MyApp(),
    ),
  );
}

// Widget usage
class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<UserState>(
      builder: (context, userState, child) {
        if (userState.isLoading) {
          return LoadingIndicator();
        }

        if (!userState.isLoggedIn) {
          return LoginScreen();
        }

        return ProfileContent(user: userState.currentUser!);
      },
    );
  }
}
```

### Riverpod Pattern (Recommended for Large Apps)

**Priority**: Medium
**Complexity**: High
**Best for**: Large apps, complex business logic, team development

```dart
// Providers
final userRepositoryProvider = Provider<UserRepository>((ref) {
  return UserRepository(ApiClient());
});

final currentUserProvider = StateNotifierProvider<UserNotifier, AsyncValue<User?>>((ref) {
  return UserNotifier(ref.watch(userRepositoryProvider));
});

// State notifier
class UserNotifier extends StateNotifier<AsyncValue<User?>> {
  final UserRepository _repository;

  UserNotifier(this._repository) : super(const AsyncValue.loading());

  Future<void> login(String email, String password) async {
    state = const AsyncValue.loading();

    try {
      final user = await _repository.login(email, password);
      state = AsyncValue.data(user);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }
}

// Widget usage
class ProfileScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userState = ref.watch(currentUserProvider);

    return userState.when(
      loading: () => LoadingIndicator(),
      error: (error, stack) => ErrorDisplay(error.toString()),
      data: (user) => user != null
          ? ProfileContent(user: user)
          : LoginScreen(),
    );
  }
}
```

## 4. NAVIGATION ARCHITECTURE

### Centralized Navigation Service

**Priority**: High
**Benefits**: Consistent behavior, easy to modify globally, type-safe

```dart
class NavigationService {
  static final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

  static BuildContext get context => navigatorKey.currentContext!;

  // Basic navigation
  static Future<T?> push<T>(Widget screen) {
    return Navigator.of(context).push<T>(
      MaterialPageRoute(builder: (_) => screen),
    );
  }

  static Future<T?> pushReplacement<T>(Widget screen) {
    return Navigator.of(context).pushReplacement<T, void>(
      MaterialPageRoute(builder: (_) => screen),
    );
  }

  static Future<T?> pushAndRemoveUntil<T>(
    Widget screen, {
    bool Function(Route<dynamic>)? predicate,
  }) {
    return Navigator.of(context).pushAndRemoveUntil<T>(
      MaterialPageRoute(builder: (_) => screen),
      predicate ?? (route) => false,
    );
  }

  static void pop<T>([T? result]) {
    Navigator.of(context).pop(result);
  }

  // Named routes
  static Future<T?> pushNamed<T>(String routeName, {Object? arguments}) {
    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);
  }

  // Dialog navigation
  static Future<T?> showDialogCustom<T>(Widget dialog) {
    return showDialog<T>(
      context: context,
      builder: (_) => dialog,
    );
  }

  // Bottom sheet navigation
  static Future<T?> showBottomSheetCustom<T>(Widget sheet) {
    return showModalBottomSheet<T>(
      context: context,
      builder: (_) => sheet,
    );
  }
}

// App setup
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: NavigationService.navigatorKey,
      home: HomeScreen(),
      routes: {
        '/profile': (context) => ProfileScreen(),
        '/settings': (context) => SettingsScreen(),
      },
    );
  }
}
```

### Route Generation Pattern

**Priority**: Medium
**Use Case**: Type-safe navigation with parameters

```dart
// Route definitions
abstract class AppRoutes {
  static const String home = '/';
  static const String profile = '/profile';
  static const String productDetail = '/product';
  static const String settings = '/settings';
}

// Route arguments
class ProductDetailArguments {
  final String productId;
  final String? category;

  ProductDetailArguments({
    required this.productId,
    this.category,
  });
}

// Route generator
class RouteGenerator {
  static Route<dynamic> generateRoute(RouteSettings settings) {
    switch (settings.name) {
      case AppRoutes.home:
        return MaterialPageRoute(builder: (_) => HomeScreen());

      case AppRoutes.profile:
        return MaterialPageRoute(builder: (_) => ProfileScreen());

      case AppRoutes.productDetail:
        if (settings.arguments is ProductDetailArguments) {
          final args = settings.arguments as ProductDetailArguments;
          return MaterialPageRoute(
            builder: (_) => ProductDetailScreen(
              productId: args.productId,
              category: args.category,
            ),
          );
        }
        return _errorRoute();

      default:
        return _errorRoute();
    }
  }

  static Route<dynamic> _errorRoute() {
    return MaterialPageRoute(
      builder: (_) => Scaffold(
        body: Center(
          child: Text('Route not found'),
        ),
      ),
    );
  }
}

// Usage
NavigationService.pushNamed(
  AppRoutes.productDetail,
  arguments: ProductDetailArguments(
    productId: 'product-123',
    category: 'electronics',
  ),
);
```

## 5. DEPENDENCY INJECTION PATTERNS

### Service Locator Pattern (Simple)

**Priority**: Medium
**Use Case**: Small to medium apps with clear service dependencies

```dart
class ServiceLocator {
  static final ServiceLocator _instance = ServiceLocator._internal();
  factory ServiceLocator() => _instance;
  ServiceLocator._internal();

  final Map<Type, dynamic> _services = {};

  void register<T>(T service) {
    _services[T] = service;
  }

  T get<T>() {
    final service = _services[T];
    if (service == null) {
      throw Exception('Service of type $T not registered');
    }
    return service as T;
  }

  void reset() {
    _services.clear();
  }
}

// Setup (in main.dart)
void main() {
  _setupServices();
  runApp(MyApp());
}

void _setupServices() {
  final locator = ServiceLocator();
  locator.register<ApiClient>(ApiClient());
  locator.register<UserRepository>(UserRepository(locator.get<ApiClient>()));
  locator.register<UserService>(UserService(locator.get<UserRepository>()));
}

// Usage
class UserScreen extends StatefulWidget {
  @override
  State<UserScreen> createState() => _UserScreenState();
}

class _UserScreenState extends State<UserScreen> {
  late final UserService _userService = ServiceLocator().get<UserService>();

  // Use _userService...
}
```

### Constructor Injection Pattern (Testable)

**Priority**: High
**Use Case**: Large apps, team development, high testability requirements

```dart
// Abstract interfaces
abstract class UserRepository {
  Future<User> getUser(String id);
  Future<void> updateUser(User user);
}

abstract class NotificationService {
  Future<void> sendNotification(String message);
}

// Concrete implementations
class ApiUserRepository implements UserRepository {
  final ApiClient _apiClient;

  ApiUserRepository(this._apiClient);

  @override
  Future<User> getUser(String id) async {
    final response = await _apiClient.get('/users/$id');
    return User.fromJson(response.data);
  }

  @override
  Future<void> updateUser(User user) async {
    await _apiClient.put('/users/${user.id}', user.toJson());
  }
}

// Service with dependencies
class UserService {
  final UserRepository _userRepository;
  final NotificationService _notificationService;

  UserService(this._userRepository, this._notificationService);

  Future<void> updateUserProfile(User user) async {
    await _userRepository.updateUser(user);
    await _notificationService.sendNotification('Profile updated');
  }
}

// Screen with dependency injection
class UserProfileScreen extends StatefulWidget {
  final UserService userService;

  const UserProfileScreen({
    super.key,
    required this.userService,
  });

  @override
  State<UserProfileScreen> createState() => _UserProfileScreenState();
}

// Testing becomes easy
class MockUserRepository implements UserRepository {
  @override
  Future<User> getUser(String id) async {
    return User(id: id, name: 'Test User');
  }

  @override
  Future<void> updateUser(User user) async {
    // Mock implementation
  }
}

void main() {
  testWidgets('UserProfileScreen updates user', (tester) async {
    final mockRepo = MockUserRepository();
    final mockNotification = MockNotificationService();
    final userService = UserService(mockRepo, mockNotification);

    await tester.pumpWidget(
      MaterialApp(
        home: UserProfileScreen(userService: userService),
      ),
    );

    // Test interactions...
  });
}
```

## 6. ERROR HANDLING ARCHITECTURE

### Layered Error Handling

**Priority**: High
**Pattern**: Transform technical errors to user-friendly messages at each layer

```dart
// Custom exception hierarchy
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic originalError;

  AppException(this.message, {this.code, this.originalError});

  @override
  String toString() => message;
}

class NetworkException extends AppException {
  NetworkException(String message, {String? code, dynamic originalError})
      : super(message, code: code ?? 'NETWORK_ERROR', originalError: originalError);
}

class ValidationException extends AppException {
  ValidationException(String message, {String? code})
      : super(message, code: code ?? 'VALIDATION_ERROR');
}

class BusinessLogicException extends AppException {
  BusinessLogicException(String message, {String? code})
      : super(message, code: code ?? 'BUSINESS_ERROR');
}

// Repository layer - Technical error handling
class ApiRepository {
  Future<Result> fetchData() async {
    try {
      final response = await _apiClient.get('/data');
      return Result.fromJson(response.data);
    } on SocketException {
      throw NetworkException('No internet connection');
    } on TimeoutException {
      throw NetworkException('Request timeout');
    } on HttpException catch (e) {
      throw NetworkException('Server error: ${e.message}');
    } catch (e) {
      throw NetworkException('Network error occurred', originalError: e);
    }
  }
}

// Service layer - Business logic error handling
class DataService {
  final ApiRepository _repository;

  DataService(this._repository);

  Future<ProcessedResult> processData(String input) async {
    // Validation
    if (input.isEmpty) {
      throw ValidationException('Input cannot be empty');
    }

    try {
      final rawData = await _repository.fetchData();

      // Business logic
      if (rawData.isEmpty) {
        throw BusinessLogicException('No data available for processing');
      }

      return _processBusinessLogic(rawData, input);
    } catch (AppException) {
      rethrow; // Re-throw known exceptions
    } catch (e) {
      throw BusinessLogicException('Processing failed', originalError: e);
    }
  }
}

// Presentation layer - UI error handling
class _ScreenState extends State<Screen> {
  String? _errorMessage;

  Future<void> _loadData() async {
    try {
      await _dataService.processData(input);
      // Success handling
    } on NetworkException catch (e) {
      setState(() => _errorMessage = 'Connection problem: ${e.message}');
    } on ValidationException catch (e) {
      setState(() => _errorMessage = 'Input error: ${e.message}');
    } on BusinessLogicException catch (e) {
      setState(() => _errorMessage = 'Processing error: ${e.message}');
    } on AppException catch (e) {
      setState(() => _errorMessage = 'Error: ${e.message}');
    }
  }
}
```

### Global Error Handler

**Priority**: Medium
**Use Case**: Centralized error logging and crash reporting

```dart
class GlobalErrorHandler {
  static void initialize() {
    // Handle Flutter framework errors
    FlutterError.onError = (FlutterErrorDetails details) {
      FlutterError.presentError(details);
      _logError(details.exception, details.stack);
    };

    // Handle async errors
    PlatformDispatcher.instance.onError = (error, stack) {
      _logError(error, stack);
      return true;
    };
  }

  static void _logError(dynamic error, StackTrace? stack) {
    // Log to console
    debugPrint('Error: $error');
    if (stack != null) {
      debugPrint('Stack trace: $stack');
    }

    // Send to crash reporting service
    // CrashReporting.recordError(error, stack);

    // Send to analytics
    // Analytics.logError(error.toString());
  }

  static void handleError(AppException error, {StackTrace? stack}) {
    _logError(error, stack);

    // Additional handling based on error type
    if (error is NetworkException) {
      // Handle network errors
    } else if (error is ValidationException) {
      // Handle validation errors
    }
  }
}

// Usage in main.dart
void main() {
  GlobalErrorHandler.initialize();
  runApp(MyApp());
}
```

## 7. DATA FLOW PATTERNS

### Unidirectional Data Flow

**Priority**: High
**Pattern**: User Action â†’ Event Handler â†’ Service Call â†’ State Update â†’ UI Rebuild

```dart
// Event types
abstract class UserEvent {}
class LoadDataEvent extends UserEvent {}
class RefreshDataEvent extends UserEvent {}
class FilterDataEvent extends UserEvent {
  final String filter;
  FilterDataEvent(this.filter);
}

// State management with events
class DataScreenController {
  final DataService _dataService;

  // State
  final ValueNotifier<bool> isLoading = ValueNotifier(false);
  final ValueNotifier<List<DataModel>> items = ValueNotifier([]);
  final ValueNotifier<String?> error = ValueNotifier(null);

  DataScreenController(this._dataService);

  void handleEvent(UserEvent event) {
    switch (event.runtimeType) {
      case LoadDataEvent:
        _loadData();
        break;
      case RefreshDataEvent:
        _refreshData();
        break;
      case FilterDataEvent:
        _filterData((event as FilterDataEvent).filter);
        break;
    }
  }

  Future<void> _loadData() async {
    isLoading.value = true;
    error.value = null;

    try {
      final data = await _dataService.fetchData();
      items.value = data;
    } catch (e) {
      error.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }

  void dispose() {
    isLoading.dispose();
    items.dispose();
    error.dispose();
  }
}

// UI implementation
class DataScreen extends StatefulWidget {
  @override
  State<DataScreen> createState() => _DataScreenState();
}

class _DataScreenState extends State<DataScreen> {
  late final DataScreenController _controller;

  @override
  void initState() {
    super.initState();
    _controller = DataScreenController(DataService());
    _controller.handleEvent(LoadDataEvent());
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Loading indicator
          ValueListenableBuilder<bool>(
            valueListenable: _controller.isLoading,
            builder: (context, isLoading, child) {
              return isLoading
                  ? LinearProgressIndicator()
                  : SizedBox.shrink();
            },
          ),

          // Error display
          ValueListenableBuilder<String?>(
            valueListenable: _controller.error,
            builder: (context, error, child) {
              return error != null
                  ? ErrorBanner(
                      message: error,
                      onRetry: () => _controller.handleEvent(LoadDataEvent()),
                    )
                  : SizedBox.shrink();
            },
          ),

          // Data list
          Expanded(
            child: ValueListenableBuilder<List<DataModel>>(
              valueListenable: _controller.items,
              builder: (context, items, child) {
                return ListView.builder(
                  itemCount: items.length,
                  itemBuilder: (context, index) {
                    return DataItemWidget(item: items[index]);
                  },
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _controller.handleEvent(RefreshDataEvent()),
        child: Icon(Icons.refresh),
      ),
    );
  }
}
```

## 8. TESTING ARCHITECTURE

### Testing Strategy

**Priority**: High
**Layers**: Unit tests for services, Widget tests for UI, Integration tests for flows

```dart
// Unit test template for services
class MockApiClient extends Mock implements ApiClient {}

void main() {
  group('UserService Tests', () {
    late UserService userService;
    late MockApiClient mockApiClient;
    late UserRepository userRepository;

    setUp(() {
      mockApiClient = MockApiClient();
      userRepository = ApiUserRepository(mockApiClient);
      userService = UserService(userRepository);
    });

    test('getUserProfile returns user on success', () async {
      // Arrange
      final expectedUser = User(id: '1', name: 'John Doe');
      when(mockApiClient.get('/users/1')).thenAnswer(
        (_) async => ApiResponse(data: expectedUser.toJson()),
      );

      // Act
      final result = await userService.getUserProfile('1');

      // Assert
      expect(result.id, equals('1'));
      expect(result.name, equals('John Doe'));
      verify(mockApiClient.get('/users/1')).called(1);
    });

    test('getUserProfile throws NetworkException on network error', () async {
      // Arrange
      when(mockApiClient.get('/users/1')).thenThrow(SocketException('No internet'));

      // Act & Assert
      expect(
        () => userService.getUserProfile('1'),
        throwsA(isA<NetworkException>()),
      );
    });
  });
}

// Widget test template
void main() {
  group('UserProfileScreen Tests', () {
    late MockUserService mockUserService;

    setUp(() {
      mockUserService = MockUserService();
    });

    testWidgets('displays user profile when loaded', (tester) async {
      // Arrange
      final user = User(id: '1', name: 'John Doe');
      when(mockUserService.getUserProfile('1')).thenAnswer((_) async => user);

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: UserProfileScreen(
            userId: '1',
            userService: mockUserService,
          ),
        ),
      );
      await tester.pumpAndSettle();

      // Assert
      expect(find.text('John Doe'), findsOneWidget);
      verify(mockUserService.getUserProfile('1')).called(1);
    });

    testWidgets('displays error message on service failure', (tester) async {
      // Arrange
      when(mockUserService.getUserProfile('1')).thenThrow(
        NetworkException('Network error'),
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: UserProfileScreen(
            userId: '1',
            userService: mockUserService,
          ),
        ),
      );
      await tester.pumpAndSettle();

      // Assert
      expect(find.text('Network error'), findsOneWidget);
    });
  });
}

// Integration test template
void main() {
  group('User Flow Integration Tests', () {
    testWidgets('complete user login and profile view flow', (tester) async {
      // Arrange
      await tester.pumpWidget(MyApp());

      // Act - Navigate to login
      await tester.tap(find.text('Login'));
      await tester.pumpAndSettle();

      // Act - Enter credentials
      await tester.enterText(find.byType(TextFormField).at(0), 'user@example.com');
      await tester.enterText(find.byType(TextFormField).at(1), 'password');
      await tester.tap(find.text('Submit'));
      await tester.pumpAndSettle();

      // Assert - Profile screen is displayed
      expect(find.text('Profile'), findsOneWidget);
      expect(find.text('Welcome'), findsOneWidget);
    });
  });
}
```

---

## ARCHITECTURAL DECISIONS FRAMEWORK

### Decision Template

```markdown
### Decision: [Title]

**Date**: [Date]
**Status**: [Proposed/Accepted/Deprecated]
**Context**: [What is the issue that we're seeing?]
**Decision**: [What is the change that we're proposing/doing?]
**Consequences**:

- âœ… Positive consequences
- âŒ Negative consequences
- ğŸ”„ Neutral consequences
```

### Common Architectural Decisions

#### State Management Choice

**Context**: Need to manage application state
**Options**: setState, Provider, Riverpod, Bloc, Redux
**Decision Factors**:

- App complexity
- Team size and experience
- Testability requirements
- Performance needs

#### Navigation Strategy

**Context**: Need to handle screen navigation
**Options**: Navigator 1.0, Navigator 2.0, Auto Route, Go Router
**Decision Factors**:

- Deep linking requirements
- Web support needs
- Route complexity
- Type safety requirements

#### Dependency Injection

**Context**: Need to manage service dependencies
**Options**: Service Locator, Constructor Injection, Provider-based DI
**Decision Factors**:

- Testability requirements
- App complexity
- Team preferences
- Build-time vs runtime resolution

---

_Universal architectural patterns for Flutter/Dart applications_
_Last updated: January 2025_
