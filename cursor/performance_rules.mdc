# Performance Rules & Optimization Guidelines
*Universal Flutter/Dart performance optimization patterns*

## 1. WIDGET PERFORMANCE OPTIMIZATIONS

### ValueListenableBuilder Pattern
**Priority**: High
**Use Case**: Localized UI updates without full widget rebuilds
**Performance Impact**: 70-90% reduction in rebuild scope

**Problem**: Inefficient setState causing full widget rebuilds
```dart
// ❌ INEFFICIENT - Full widget rebuild on every change
class _CounterWidgetState extends State<CounterWidget> {
  int _counter = 0;
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text('Counter App'),           // Rebuilds unnecessarily
        Text('Count: $_counter'),           // Only this needs to update
        const SizedBox(height: 16),         // Rebuilds unnecessarily
        ElevatedButton(
          onPressed: () => setState(() => _counter++),
          child: const Text('Increment'),   // Rebuilds unnecessarily
        ),
      ],
    );
  }
}
```

**Solution**: Use ValueListenableBuilder for localized updates
```dart
// ✅ OPTIMIZED - Only counter text rebuilds
class _CounterWidgetState extends State<CounterWidget> {
  final ValueNotifier<int> _counter = ValueNotifier(0);
  
  @override
  void dispose() {
    _counter.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text('Counter App'),           // ✅ Never rebuilds
        ValueListenableBuilder<int>(
          valueListenable: _counter,
          builder: (context, count, child) {
            return Text('Count: $count');    // ✅ Only this rebuilds
          },
        ),
        const SizedBox(height: 16),         // ✅ Never rebuilds
        ElevatedButton(
          onPressed: () => _counter.value++,
          child: const Text('Increment'),   // ✅ Never rebuilds
        ),
      ],
    );
  }
}
```

**Template for Complex Forms**:
```dart
class _FormState extends State<Form> {
  final ValueNotifier<bool> _isValid = ValueNotifier(false);
  final ValueNotifier<bool> _isLoading = ValueNotifier(false);
  final TextEditingController _controller = TextEditingController();
  
  @override
  void dispose() {
    _isValid.dispose();
    _isLoading.dispose();
    _controller.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Static form fields - never rebuild
        TextField(
          controller: _controller,
          onChanged: _validateForm,
          decoration: InputDecoration(
            // Dynamic suffix icon - only rebuilds when needed
            suffixIcon: ValueListenableBuilder<TextEditingValue>(
              valueListenable: _controller,
              builder: (context, value, child) {
                return value.text.isNotEmpty
                    ? IconButton(
                        onPressed: _controller.clear,
                        icon: Icon(Icons.clear),
                      )
                    : SizedBox.shrink();
              },
            ),
          ),
        ),
        
        // Dynamic submit button - only rebuilds when validation changes
        ValueListenableBuilder<bool>(
          valueListenable: _isValid,
          builder: (context, isValid, child) {
            return ValueListenableBuilder<bool>(
              valueListenable: _isLoading,
              builder: (context, isLoading, child) {
                return ElevatedButton(
                  onPressed: isValid && !isLoading ? _submit : null,
                  child: isLoading
                      ? CircularProgressIndicator()
                      : Text('Submit'),
                );
              },
            );
          },
        ),
      ],
    );
  }
}
```

### Const Constructor Optimization
**Priority**: High
**Performance Impact**: Prevents unnecessary widget creation and comparison

**Const Usage Rules**:
```dart
// ✅ GOOD - Static widgets with const
const SizedBox(height: 16),
const Divider(),
const CircularProgressIndicator(),
const Text('Static text'),

// ✅ GOOD - Const constructors for custom widgets
const AppHeader(title: 'Static Title'),
const LoadingIndicator(message: 'Loading...'),
const ErrorDisplay(message: 'Error occurred'),

// ✅ GOOD - Const in widget trees
Column(
  children: [
    const AppHeader(),              // Never recreated
    Expanded(child: _buildBody()),  // Dynamic content
    const SizedBox(height: 24),    // Never recreated
  ],
)

// ❌ AVOID - Missing const for static content
SizedBox(height: 16),        // Should be const
Text('Static text'),         // Should be const
AppHeader(title: 'Title'),   // Should be const if title is static
```

**Template for Const-Friendly Widgets**:
```dart
class OptimizedWidget extends StatelessWidget {
  final String title;
  final VoidCallback? onPressed;
  final bool isEnabled;
  final Color? backgroundColor;

  const OptimizedWidget({
    super.key,
    required this.title,
    this.onPressed,
    this.isEnabled = true,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      color: backgroundColor ?? Theme.of(context).colorScheme.surface,
      child: Column(
        children: [
          // ✅ Use const for static elements
          const Icon(Icons.star),
          const SizedBox(height: 8),
          
          // Dynamic content
          Text(title),
          
          // ✅ Conditional const widgets
          if (isEnabled)
            const Text('Enabled')
          else
            const Text('Disabled'),
          
          // ✅ Static action buttons
          ElevatedButton(
            onPressed: onPressed,
            child: const Text('Action'), // Const child
          ),
        ],
      ),
    );
  }
}
```

### Widget Extraction for Performance
**Priority**: High
**Rule**: Extract static UI components to prevent unnecessary rebuilds

**Before Optimization** (inline widgets causing rebuilds):
```dart
class _SearchScreenState extends State<SearchScreen> {
  String _query = '';
  List<Item> _results = [];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // ❌ This entire header rebuilds when _query or _results change
          Container(
            padding: EdgeInsets.all(16),
            child: Row(
              children: [
                IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: Icon(Icons.arrow_back),
                ),
                Expanded(
                  child: Text(
                    'Search Results',
                    style: Theme.of(context).textTheme.headlineMedium,
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.pushNamed(context, '/settings'),
                  icon: Icon(Icons.settings),
                ),
              ],
            ),
          ),
          
          TextField(
            onChanged: (value) => setState(() => _query = value),
          ),
          
          Expanded(
            child: ListView.builder(
              itemCount: _results.length,
              itemBuilder: (context, index) => ListTile(
                title: Text(_results[index].title),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

**After Optimization** (extracted static widgets):
```dart
class _SearchScreenState extends State<SearchScreen> {
  String _query = '';
  List<Item> _results = [];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          const SearchHeader(), // ✅ Const widget - never rebuilds
          
          SearchField(
            onChanged: (value) => setState(() => _query = value),
          ),
          
          Expanded(
            child: SearchResults(results: _results), // ✅ Only rebuilds when results change
          ),
        ],
      ),
    );
  }
}

// ✅ Extracted static header widget
class SearchHeader extends StatelessWidget {
  const SearchHeader({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(16),
      child: Row(
        children: [
          IconButton(
            onPressed: () => Navigator.pop(context),
            icon: Icon(Icons.arrow_back),
          ),
          Expanded(
            child: Text(
              'Search Results',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
          ),
          IconButton(
            onPressed: () => Navigator.pushNamed(context, '/settings'),
            icon: Icon(Icons.settings),
          ),
        ],
      ),
    );
  }
}
```

## 2. MEMORY MANAGEMENT

### Resource Disposal Pattern
**Priority**: High
**Rule**: Always dispose of controllers, notifiers, and subscriptions

**Complete Disposal Template**:
```dart
class _ScreenState extends State<Screen> {
  // Controllers that need disposal
  final TextEditingController _textController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final AnimationController _animController = AnimationController(
    duration: Duration(milliseconds: 300),
    vsync: this,
  );
  final FocusNode _focusNode = FocusNode();
  
  // Notifiers that need disposal
  final ValueNotifier<bool> _isLoading = ValueNotifier(false);
  final ValueNotifier<String> _status = ValueNotifier('Ready');
  
  // Subscriptions that need cancellation
  StreamSubscription? _dataSubscription;
  Timer? _periodicTimer;
  
  @override
  void initState() {
    super.initState();
    
    _dataSubscription = _dataStream.listen((data) {
      // Handle data
    });
    
    _periodicTimer = Timer.periodic(Duration(seconds: 30), (timer) {
      // Periodic task
    });
  }
  
  @override
  void dispose() {
    // Dispose controllers
    _textController.dispose();
    _scrollController.dispose();
    _animController.dispose();
    _focusNode.dispose();
    
    // Dispose notifiers
    _isLoading.dispose();
    _status.dispose();
    
    // Cancel subscriptions
    _dataSubscription?.cancel();
    _periodicTimer?.cancel();
    
    super.dispose();
  }
}
```

**Memory Leak Detection Template**:
```dart
class MemoryTracker {
  static final Map<String, int> _instanceCounts = {};
  
  static void trackInstance(String className) {
    _instanceCounts[className] = (_instanceCounts[className] ?? 0) + 1;
    debugPrint('Created $className. Count: ${_instanceCounts[className]}');
  }
  
  static void untrackInstance(String className) {
    _instanceCounts[className] = (_instanceCounts[className] ?? 1) - 1;
    debugPrint('Disposed $className. Count: ${_instanceCounts[className]}');
  }
  
  static void printMemoryReport() {
    debugPrint('=== Memory Report ===');
    _instanceCounts.forEach((className, count) {
      if (count > 0) {
        debugPrint('$className: $count instances (potential leak)');
      }
    });
  }
}

// Usage in widgets
class _ScreenState extends State<Screen> {
  @override
  void initState() {
    super.initState();
    MemoryTracker.trackInstance('Screen');
  }
  
  @override
  void dispose() {
    MemoryTracker.untrackInstance('Screen');
    super.dispose();
  }
}
```

### Async Operation Safety
**Priority**: High
**Rule**: Always check `mounted` before setState in async operations

**Safe Async Pattern**:
```dart
class _ScreenState extends State<Screen> {
  bool _isLoading = false;
  String? _errorMessage;
  List<DataModel> _data = [];

  Future<void> _loadData() async {
    if (!mounted) return; // Early exit if widget disposed
    
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    
    try {
      final data = await _apiService.fetchData();
      
      // ✅ Check mounted before setState
      if (mounted) {
        setState(() {
          _data = data;
          _isLoading = false;
        });
      }
    } catch (e) {
      // ✅ Check mounted before setState
      if (mounted) {
        setState(() {
          _errorMessage = e.toString();
          _isLoading = false;
        });
      }
    }
  }
  
  Future<void> _performLongOperation() async {
    for (int i = 0; i < 100; i++) {
      await Future.delayed(Duration(milliseconds: 10));
      
      // ✅ Check mounted during long operations
      if (!mounted) return;
      
      // Update progress
      if (mounted) {
        setState(() => _progress = i / 100);
      }
    }
  }
}
```

**Cancellable Async Operations**:
```dart
class _ScreenState extends State<Screen> {
  CancelToken? _cancelToken;
  
  Future<void> _loadData() async {
    _cancelToken?.cancel();
    _cancelToken = CancelToken();
    
    try {
      final data = await _apiService.fetchData(cancelToken: _cancelToken);
      if (mounted) {
        setState(() => _data = data);
      }
    } on CancelException {
      // Operation was cancelled - no need to update UI
    } catch (e) {
      if (mounted) {
        setState(() => _errorMessage = e.toString());
      }
    }
  }
  
  @override
  void dispose() {
    _cancelToken?.cancel();
    super.dispose();
  }
}
```

## 3. LIST PERFORMANCE

### ListView Optimization
**Priority**: High
**Rule**: Use ListView.builder for lists with more than 20-30 items

**Small List (< 30 items)**:
```dart
// ✅ ACCEPTABLE for small lists
class SmallList extends StatelessWidget {
  final List<Item> items;

  const SmallList({super.key, required this.items});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: items.map((item) => ItemTile(
        key: ValueKey(item.id), // ✅ Stable key
        item: item,
      )).toList(),
    );
  }
}
```

**Large List (30+ items)**:
```dart
// ✅ REQUIRED for large lists
class LargeList extends StatelessWidget {
  final List<Item> items;
  final void Function(Item) onItemTap;

  const LargeList({
    super.key,
    required this.items,
    required this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];
        return ItemTile(
          key: ValueKey(item.id), // ✅ Stable key for performance
          item: item,
          onTap: () => onItemTap(item),
        );
      },
    );
  }
}
```

**Infinite Scroll Pattern**:
```dart
class InfiniteScrollList extends StatefulWidget {
  @override
  State<InfiniteScrollList> createState() => _InfiniteScrollListState();
}

class _InfiniteScrollListState extends State<InfiniteScrollList> {
  final ScrollController _scrollController = ScrollController();
  final List<Item> _items = [];
  bool _isLoading = false;
  bool _hasMore = true;
  int _page = 1;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    _loadMore();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      _loadMore();
    }
  }

  Future<void> _loadMore() async {
    if (_isLoading || !_hasMore) return;

    setState(() => _isLoading = true);

    try {
      final newItems = await _apiService.fetchItems(page: _page);
      
      if (mounted) {
        setState(() {
          _items.addAll(newItems);
          _page++;
          _hasMore = newItems.isNotEmpty;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: _scrollController,
      itemCount: _items.length + (_hasMore ? 1 : 0),
      itemBuilder: (context, index) {
        if (index == _items.length) {
          return _isLoading
              ? Center(child: CircularProgressIndicator())
              : SizedBox.shrink();
        }

        final item = _items[index];
        return ItemTile(
          key: ValueKey(item.id),
          item: item,
        );
      },
    );
  }
}
```

### Key Usage for List Performance
**Priority**: High
**Rule**: Use stable, unique keys for list items

```dart
// ✅ GOOD - Stable keys based on unique identifiers
ListView.builder(
  itemBuilder: (context, index) {
    final item = items[index];
    return ItemWidget(
      key: ValueKey(item.id), // Unique, stable identifier
      item: item,
    );
  },
)

// ✅ GOOD - ObjectKey for complex objects
ListView.builder(
  itemBuilder: (context, index) {
    final item = items[index];
    return ItemWidget(
      key: ObjectKey(item), // Uses object equality
      item: item,
    );
  },
)

// ❌ AVOID - No keys (causes rebuild issues when list changes)
ListView.builder(
  itemBuilder: (context, index) {
    return ItemWidget(item: items[index]);
  },
)

// ❌ AVOID - Index keys (unstable when list reorders)
ListView.builder(
  itemBuilder: (context, index) {
    return ItemWidget(
      key: ValueKey(index), // Bad - index changes when list reorders
      item: items[index],
    );
  },
)

// ❌ AVOID - Random keys (always rebuilds)
ListView.builder(
  itemBuilder: (context, index) {
    return ItemWidget(
      key: UniqueKey(), // Bad - always different
      item: items[index],
    );
  },
)
```

## 4. IMAGE & ASSET OPTIMIZATION

### Image Loading Performance
**Priority**: Medium
**Rule**: Always specify dimensions and use appropriate cache settings

**Optimized Image Loading**:
```dart
class OptimizedImage extends StatelessWidget {
  final String imagePath;
  final double width;
  final double height;
  final BoxFit fit;

  const OptimizedImage({
    super.key,
    required this.imagePath,
    required this.width,
    required this.height,
    this.fit = BoxFit.cover,
  });

  @override
  Widget build(BuildContext context) {
    return Image.asset(
      imagePath,
      width: width,
      height: height,
      fit: fit,
      // ✅ Cache at display resolution
      cacheWidth: width.toInt(),
      cacheHeight: height.toInt(),
      // ✅ Error handling
      errorBuilder: (context, error, stackTrace) {
        return Container(
          width: width,
          height: height,
          color: Theme.of(context).colorScheme.errorContainer,
          child: Icon(
            Icons.broken_image,
            color: Theme.of(context).colorScheme.error,
          ),
        );
      },
    );
  }
}

// Network image with caching
class OptimizedNetworkImage extends StatelessWidget {
  final String imageUrl;
  final double width;
  final double height;

  const OptimizedNetworkImage({
    super.key,
    required this.imageUrl,
    required this.width,
    required this.height,
  });

  @override
  Widget build(BuildContext context) {
    return Image.network(
      imageUrl,
      width: width,
      height: height,
      fit: BoxFit.cover,
      cacheWidth: width.toInt(),
      cacheHeight: height.toInt(),
      loadingBuilder: (context, child, loadingProgress) {
        if (loadingProgress == null) return child;
        
        return Container(
          width: width,
          height: height,
          child: Center(
            child: CircularProgressIndicator(
              value: loadingProgress.expectedTotalBytes != null
                  ? loadingProgress.cumulativeBytesLoaded /
                      loadingProgress.expectedTotalBytes!
                  : null,
            ),
          ),
        );
      },
      errorBuilder: (context, error, stackTrace) {
        return Container(
          width: width,
          height: height,
          color: Theme.of(context).colorScheme.errorContainer,
          child: Icon(Icons.broken_image),
        );
      },
    );
  }
}
```

### Asset Preloading
**Priority**: Low
**Use Case**: Critical images that should be loaded immediately

```dart
class AssetPreloader {
  static Future<void> preloadImages(BuildContext context) async {
    final imagesToPreload = [
      'assets/images/logo.png',
      'assets/images/splash_bg.png',
      'assets/images/default_avatar.png',
    ];

    await Future.wait(
      imagesToPreload.map((imagePath) => 
        precacheImage(AssetImage(imagePath), context)
      ),
    );
  }
}

// Usage in main.dart or splash screen
class SplashScreen extends StatefulWidget {
  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  Future<void> _initializeApp() async {
    // Preload critical images
    await AssetPreloader.preloadImages(context);
    
    // Other initialization...
    
    // Navigate to main app
    if (mounted) {
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (_) => MainApp()),
      );
    }
  }
}
```

## 5. BUILD METHOD OPTIMIZATION

### Build Method Structure
**Priority**: High
**Rule**: Separate static and dynamic content, use build helper methods

**Optimized Build Method Pattern**:
```dart
class _ScreenState extends State<Screen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surface,
      body: Column(
        children: [
          _buildStaticHeader(),    // ✅ Static content
          _buildDynamicContent(),  // ✅ Dynamic content
          _buildStaticFooter(),    // ✅ Static content
        ],
      ),
    );
  }

  Widget _buildStaticHeader() {
    // ✅ Static content that never changes
    return const AppHeader(title: 'Screen Title');
  }

  Widget _buildDynamicContent() {
    // ✅ Content that may change based on state
    return Expanded(
      child: _isLoading
          ? const LoadingIndicator()
          : _hasError
              ? ErrorDisplay(message: _errorMessage!)
              : _buildDataList(),
    );
  }

  Widget _buildDataList() {
    return ListView.builder(
      itemCount: _data.length,
      itemBuilder: (context, index) {
        return DataTile(
          key: ValueKey(_data[index].id),
          data: _data[index],
        );
      },
    );
  }

  Widget _buildStaticFooter() {
    // ✅ Static footer that never changes
    return Container(
      padding: EdgeInsets.all(16),
      child: const Text('Footer content'),
    );
  }
}
```

### Conditional Widget Optimization
**Priority**: Medium
**Rule**: Use efficient conditional rendering patterns

```dart
class ConditionalWidgets extends StatelessWidget {
  final bool showAdvanced;
  final List<String> items;

  const ConditionalWidgets({
    super.key,
    required this.showAdvanced,
    required this.items,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text('Always visible'),
        
        // ✅ GOOD - Efficient conditional widgets
        if (showAdvanced) ...[
          const SizedBox(height: 16),
          const Text('Advanced options'),
          const AdvancedSettingsWidget(),
        ],
        
        // ✅ GOOD - Conditional widget with null fallback
        showAdvanced ? const AdvancedWidget() : null,
        
        // ✅ GOOD - Empty container when needed
        showAdvanced ? const AdvancedWidget() : const SizedBox.shrink(),
        
        // ❌ AVOID - Creating widgets that aren't used
        showAdvanced 
            ? Column(  // Creates Column even when not shown
                children: [
                  const Text('Advanced'),
                  const AdvancedWidget(),
                ],
              )
            : Container(), // Creates empty Container
      ].whereType<Widget>().toList(), // Remove null widgets
    );
  }
}
```

## 6. THEME PERFORMANCE

### Theme Access Optimization
**Priority**: Medium
**Rule**: Cache theme references when used multiple times

```dart
class _ScreenState extends State<Screen> {
  @override
  Widget build(BuildContext context) {
    // ✅ GOOD - Cache theme reference
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final textTheme = theme.textTheme;
    
    return Column(
      children: [
        Text('Title', style: textTheme.headlineLarge),
        Text('Subtitle', style: textTheme.bodyMedium),
        Text('Caption', style: textTheme.bodySmall),
        Container(
          color: colorScheme.primary,
          child: Text(
            'Content',
            style: textTheme.bodyLarge?.copyWith(
              color: colorScheme.onPrimary,
            ),
          ),
        ),
      ],
    );
  }
}

// ❌ AVOID - Repeated Theme.of(context) calls
class _BadScreenState extends State<Screen> {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Title', style: Theme.of(context).textTheme.headlineLarge),
        Text('Subtitle', style: Theme.of(context).textTheme.bodyMedium),
        Text('Caption', style: Theme.of(context).textTheme.bodySmall),
        Container(
          color: Theme.of(context).colorScheme.primary,
          child: Text(
            'Content',
            style: Theme.of(context).textTheme.bodyLarge?.copyWith(
              color: Theme.of(context).colorScheme.onPrimary,
            ),
          ),
        ),
      ],
    );
  }
}
```

## 7. STATE MANAGEMENT PERFORMANCE

### Efficient setState Usage
**Priority**: High
**Rule**: Minimize setState scope and batch related updates

```dart
class _ScreenState extends State<Screen> {
  bool _isLoading = false;
  String? _errorMessage;
  List<DataModel> _data = [];
  String _searchQuery = '';

  Future<void> _loadData() async {
    // ✅ GOOD - Batch related state changes
    setState(() {
      _isLoading = true;
      _errorMessage = null;  // Clear previous error
    });

    try {
      final data = await _apiService.fetchData();
      
      // ✅ GOOD - Single setState for success state
      setState(() {
        _data = data;
        _isLoading = false;
      });
    } catch (e) {
      // ✅ GOOD - Single setState for error state
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }

  void _updateSearchQuery(String query) {
    // ✅ GOOD - Only update what changed
    if (_searchQuery != query) {
      setState(() => _searchQuery = query);
    }
  }

  @override
  Widget build(BuildContext context) {
    // ✅ GOOD - Early returns for different states
    if (_isLoading) {
      return const LoadingIndicator();
    }
    
    if (_errorMessage != null) {
      return ErrorDisplay(
        message: _errorMessage!,
        onRetry: _loadData,
      );
    }
    
    return DataList(data: _data);
  }
}
```

### State Splitting for Performance
**Priority**: Medium
**Rule**: Split unrelated state to prevent unnecessary rebuilds

```dart
// ❌ BAD - Single widget with mixed concerns
class _BadScreenState extends State<Screen> {
  bool _isLoading = false;
  List<Item> _items = [];
  bool _showFilters = false;
  String _selectedFilter = '';

  @override
  Widget build(BuildContext context) {
    // Changing _showFilters rebuilds the entire item list
    return Column(
      children: [
        FilterToggle(
          showFilters: _showFilters,
          onToggle: (show) => setState(() => _showFilters = show),
        ),
        if (_showFilters)
          FilterPanel(
            selectedFilter: _selectedFilter,
            onFilterChanged: (filter) => setState(() => _selectedFilter = filter),
          ),
        Expanded(
          child: ItemList(items: _items), // Rebuilds unnecessarily
        ),
      ],
    );
  }
}

// ✅ GOOD - Split into focused widgets
class _GoodScreenState extends State<Screen> {
  bool _isLoading = false;
  List<Item> _items = [];

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const FilterSection(), // Manages its own filter state
        Expanded(
          child: _isLoading
              ? const LoadingIndicator()
              : ItemList(items: _items), // Only rebuilds when items change
        ),
      ],
    );
  }
}

class FilterSection extends StatefulWidget {
  const FilterSection({super.key});

  @override
  State<FilterSection> createState() => _FilterSectionState();
}

class _FilterSectionState extends State<FilterSection> {
  bool _showFilters = false;
  String _selectedFilter = '';

  @override
  Widget build(BuildContext context) {
    // Filter state changes only affect this widget
    return Column(
      children: [
        FilterToggle(
          showFilters: _showFilters,
          onToggle: (show) => setState(() => _showFilters = show),
        ),
        if (_showFilters)
          FilterPanel(
            selectedFilter: _selectedFilter,
            onFilterChanged: (filter) => setState(() => _selectedFilter = filter),
          ),
      ],
    );
  }
}
```

## 8. PERFORMANCE MONITORING

### Performance Profiling
**Priority**: Low
**Use Case**: Identifying performance bottlenecks

```dart
class PerformanceProfiler {
  static final Map<String, Stopwatch> _timers = {};
  
  static void startTimer(String name) {
    _timers[name] = Stopwatch()..start();
  }
  
  static void endTimer(String name) {
    final timer = _timers[name];
    if (timer != null) {
      timer.stop();
      debugPrint('$name took ${timer.elapsedMilliseconds}ms');
      _timers.remove(name);
    }
  }
  
  static T profile<T>(String name, T Function() function) {
    startTimer(name);
    try {
      return function();
    } finally {
      endTimer(name);
    }
  }
}

// Usage
class _ScreenState extends State<Screen> {
  @override
  Widget build(BuildContext context) {
    return PerformanceProfiler.profile('Screen.build', () {
      return Scaffold(
        body: _buildBody(),
      );
    });
  }
  
  Future<void> _loadData() async {
    PerformanceProfiler.startTimer('Data.load');
    try {
      final data = await _apiService.fetchData();
      setState(() => _data = data);
    } finally {
      PerformanceProfiler.endTimer('Data.load');
    }
  }
}
```

### Widget Rebuild Tracking
**Priority**: Low
**Use Case**: Identifying unnecessary rebuilds during development

```dart
class RebuildTracker extends StatelessWidget {
  final String name;
  final Widget child;

  const RebuildTracker({
    super.key,
    required this.name,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    debugPrint('Rebuilding: $name');
    return child;
  }
}

// Usage during development
class _ScreenState extends State<Screen> {
  @override
  Widget build(BuildContext context) {
    return RebuildTracker(
      name: 'MainScreen',
      child: Column(
        children: [
          RebuildTracker(
            name: 'Header',
            child: _buildHeader(),
          ),
          RebuildTracker(
            name: 'Body',
            child: _buildBody(),
          ),
        ],
      ),
    );
  }
}
```

## 9. PERFORMANCE TESTING

### Performance Test Commands
```bash
# Profile widget rebuilds
flutter run --profile --trace-widget-rebuilds

# Analyze app size
flutter build apk --analyze-size

# Memory usage profiling
flutter run --profile --trace-memory

# CPU profiling
flutter run --profile --trace-skia

# Performance overlay
flutter run --profile --trace-systrace
```

### Automated Performance Tests
**Priority**: Low
**Use Case**: Regression testing for performance

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  
  group('Performance Tests', () {
    testWidgets('List scrolling performance', (tester) async {
      await tester.pumpWidget(MyApp());
      
      // Navigate to list screen
      await tester.tap(find.text('View List'));
      await tester.pumpAndSettle();
      
      // Measure scroll performance
      await binding.traceAction(
        () async {
          final listView = find.byType(ListView);
          await tester.fling(listView, Offset(0, -500), 1000);
          await tester.pumpAndSettle();
        },
        reportKey: 'list_scroll_performance',
      );
    });
    
    testWidgets('Screen transition performance', (tester) async {
      await tester.pumpWidget(MyApp());
      
      await binding.traceAction(
        () async {
          await tester.tap(find.text('Next Screen'));
          await tester.pumpAndSettle();
        },
        reportKey: 'screen_transition_performance',
      );
    });
  });
}
```

---

## PERFORMANCE CHECKLIST

### Before Committing New Code:
- [ ] Use const constructors where possible
- [ ] Extract static widgets to prevent unnecessary rebuilds
- [ ] Dispose of all controllers, notifiers, and subscriptions
- [ ] Use ValueListenableBuilder for localized updates
- [ ] Check `mounted` before setState in async operations
- [ ] Specify image dimensions for all Image widgets
- [ ] Use stable keys for list items
- [ ] Cache Theme.of(context) if used multiple times
- [ ] Minimize setState scope - only update what changed
- [ ] Extract build helper methods for complex widgets

### Performance Red Flags:
- [ ] setState(() {}) with empty body
- [ ] Missing const on static widgets
- [ ] Controllers without disposal
- [ ] setState calls in async operations without `mounted` check
- [ ] Images without specified dimensions
- [ ] Repeated Theme.of(context) calls
- [ ] Complex widgets built inline instead of extracted
- [ ] List items without stable keys
- [ ] Unnecessary widget rebuilds (use RebuildTracker to identify)

### Performance Optimization Opportunities:
- [ ] ValueListenableBuilder instead of setState
- [ ] Widget extraction for reused/static components
- [ ] Const widget usage for static content
- [ ] ListView.builder for large lists (30+ items)
- [ ] Image caching for repeated assets
- [ ] State splitting for unrelated concerns
- [ ] Lazy loading for expensive operations
- [ ] Preloading for critical resources

---

## PERFORMANCE TARGETS

### Recommended Performance Goals:
- **Frame Rate**: Maintain 60fps during normal operation
- **Build Time**: Widget build methods < 16ms
- **Memory Usage**: No memory leaks, efficient resource cleanup
- **App Startup**: < 3 seconds on mid-range devices
- **List Scrolling**: Smooth 60fps scrolling for 1000+ items
- **Image Loading**: < 500ms for cached images
- **Screen Transitions**: < 300ms transition animations

### Performance Metrics to Monitor:
- Widget rebuild frequency
- Memory usage patterns
- Frame rendering times
- Asset loading times
- Network request durations
- Database query performance

*Universal Flutter/Dart performance optimization guidelines*
*Last updated: January 2025*