# Flutter Development Standards & Best Practices
*Universal Flutter/Dart coding standards for any application*

## 1. PROJECT ARCHITECTURE

### Standard Folder Structure
**Priority**: High
**Rationale**: Consistent organization across all Flutter projects

```
lib/
├── main.dart                    # App entry point
├── constants/                   # Static data and configuration
│   ├── app_constants.dart       # Business logic constants
│   └── [domain]_data.dart       # Domain-specific data structures
├── models/                      # Data models
│   └── [entity].dart           # Domain entities (User, Product, etc.)
├── services/                    # Business logic layer
│   ├── [external]_service.dart # External service integrations
│   ├── navigation_service.dart # Centralized navigation
│   └── [utility]_service.dart  # File processing, utilities
├── screens/                     # UI screens
│   ├── [main]_screen.dart      # Main navigation screens
│   ├── [feature]_screen.dart   # Feature-specific screens
│   └── ...
├── widgets/                     # Reusable UI components
│   ├── [layout]_widget.dart    # Layout components
│   ├── [input]_widget.dart     # Input components
│   └── ...
└── theme/                       # Design system
    └── app_theme.dart          # Centralized styling
```

**Template for new features**:
```dart
// New feature structure
lib/
├── screens/
│   └── feature_screen.dart
├── widgets/
│   └── feature_widget.dart
└── services/
    └── feature_service.dart (if needed)
```

### File Naming Conventions
**Priority**: High
**Standard**: Use snake_case with descriptive suffixes

```dart
// Screens: [feature]_screen.dart
home_screen.dart
user_profile_screen.dart
product_detail_screen.dart

// Widgets: [purpose]_[type].dart
custom_buttons.dart
app_header.dart
loading_indicator.dart

// Services: [domain]_service.dart
api_service.dart
navigation_service.dart
storage_service.dart

// Models: [entity].dart (singular)
user.dart
product.dart
order.dart

// Constants: [domain]_[type].dart
app_constants.dart
api_endpoints.dart
theme_constants.dart
```

### Import Organization
**Priority**: Medium
**Standard order**:

```dart
// 1. Flutter framework imports
import 'package:flutter/material.dart';

// 2. Third-party package imports
import 'package:http/http.dart' as http;
import 'package:provider/provider.dart';

// 3. Local imports - absolute paths from lib/
import 'config/app_config.dart';
import 'services/api_service.dart';
import 'screens/home_screen.dart';
import 'theme/app_theme.dart';

// 4. Relative imports (only when necessary)
import '../widgets/custom_buttons.dart';
```

## 2. WIDGET PATTERNS

### StatefulWidget vs StatelessWidget Rules
**Priority**: High
**Rule**: Use StatelessWidget unless state is required

**StatelessWidget Template**:
```dart
/// Brief description of widget purpose
class CustomWidget extends StatelessWidget {
  final String title;
  final VoidCallback? onPressed;
  final bool isEnabled;

  const CustomWidget({
    super.key,
    required this.title,
    this.onPressed,
    this.isEnabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      child: isEnabled
          ? ElevatedButton(
              onPressed: onPressed,
              child: Text(title),
            )
          : const Text('Disabled'),
    );
  }
}
```

**StatefulWidget Only When Needed**:
```dart
class InteractiveWidget extends StatefulWidget {
  const InteractiveWidget({super.key});

  @override
  State<InteractiveWidget> createState() => _InteractiveWidgetState();
}

class _InteractiveWidgetState extends State<InteractiveWidget> {
  bool _isExpanded = false;
  
  @override
  Widget build(BuildContext context) {
    // Implementation with state management
    return ExpansionTile(
      title: Text('Title'),
      initiallyExpanded: _isExpanded,
      onExpansionChanged: (expanded) {
        setState(() => _isExpanded = expanded);
      },
    );
  }
}
```

### Const Constructor Standards
**Priority**: High
**Rule**: Always use const constructors when possible

**Template**:
```dart
class ReusableWidget extends StatelessWidget {
  final String title;
  final VoidCallback? onPressed;
  final bool isEnabled;

  const ReusableWidget({
    super.key,  // Always use super.key
    required this.title,
    this.onPressed,
    this.isEnabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      child: isEnabled
          ? ElevatedButton(onPressed: onPressed, child: Text(title))
          : const Text('Disabled'), // Use const for static widgets
    );
  }
}
```

### Widget Extraction Guidelines
**Priority**: High
**Extraction Criteria**:
- Used in 2+ places
- Self-contained functionality
- Clear single responsibility
- Configurable through parameters

**Before (duplicated code)**:
```dart
// Repeated across multiple screens
Row(
  children: [
    IconButton(
      onPressed: () => Navigator.pop(context),
      icon: Icon(Icons.arrow_back),
    ),
    const Spacer(),
    IconButton(
      onPressed: () => Navigator.pushAndRemoveUntil(/*...*/),
      icon: Icon(Icons.home),
    ),
  ],
)
```

**After (extracted reusable widget)**:
```dart
class AppHeader extends StatelessWidget {
  final bool showBackButton;
  final bool showHomeButton;
  final VoidCallback? onBackPressed;
  final VoidCallback? onHomePressed;

  const AppHeader({
    super.key,
    this.showBackButton = true,
    this.showHomeButton = true,
    this.onBackPressed,
    this.onHomePressed,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        if (showBackButton)
          IconButton(
            onPressed: onBackPressed ?? () => Navigator.pop(context),
            icon: Icon(Icons.arrow_back),
          ),
        const Spacer(),
        if (showHomeButton)
          IconButton(
            onPressed: onHomePressed ?? () => _navigateToHome(context),
            icon: Icon(Icons.home),
          ),
      ],
    );
  }
}

// Usage:
const AppHeader(), // Simple usage with defaults
const AppHeader(showBackButton: false), // Customized
```

## 3. CODE STYLE & CONVENTIONS

### Naming Conventions
**Priority**: High

**Classes**: PascalCase
```dart
class UserService {}
class CustomTextField {}
class ApiResponse {}
```

**Variables/Methods**: camelCase
```dart
bool isLoading = false;
void performAction() {}
final TextEditingController userController;
```

**Constants**: camelCase with descriptive prefixes
```dart
// Theme constants
static const double defaultPadding = 16.0;
static const Color primaryColor = Color(0xFF2196F3);
static const String defaultFontFamily = 'Roboto';

// API constants
static const String baseUrl = 'https://api.example.com';
static const Duration defaultTimeout = Duration(seconds: 30);
```

**Private Members**: Leading underscore
```dart
class _ScreenState extends State<Screen> {
  bool _isLoading = false;
  
  Widget _buildContent() {}
  void _handleUserAction() {}
}
```

### Method Organization
**Priority**: Medium
**Standard order within classes**:

```dart
class ExampleScreen extends StatefulWidget {
  // 1. Constructor
  const ExampleScreen({super.key});

  // 2. createState (for StatefulWidget)
  @override
  State<ExampleScreen> createState() => _ExampleScreenState();
}

class _ExampleScreenState extends State<ExampleScreen> {
  // 1. Static constants
  static const double _defaultPadding = 16.0;
  
  // 2. Instance variables
  bool _isLoading = false;
  final TextEditingController _controller = TextEditingController();
  
  // 3. Lifecycle methods
  @override
  void initState() {
    super.initState();
  }
  
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
  
  // 4. Build method
  @override
  Widget build(BuildContext context) {
    return Scaffold(/* ... */);
  }
  
  // 5. Private build helper methods
  Widget _buildHeader() {}
  Widget _buildBody() {}
  
  // 6. Event handlers
  void _onButtonPressed() {}
  void _onTextChanged(String value) {}
  
  // 7. Navigation methods
  void _navigateToNextScreen() {}
}
```

### Documentation Standards
**Priority**: Medium

**Widget Documentation**:
```dart
/// Brief description of widget purpose and usage
/// 
/// Used across multiple screens for consistent [functionality]
class CustomWidget extends StatelessWidget {
  /// Description of important parameter
  final String title;
  
  /// Optional callback for user interaction
  final VoidCallback? onPressed;
  
  /// Creates a [CustomWidget] with the given [title]
  /// 
  /// The [onPressed] callback is called when user interacts with widget
  const CustomWidget({
    super.key,
    required this.title,
    this.onPressed,
  });
}
```

**Service Documentation**:
```dart
/// Service for handling [domain] operations
/// 
/// Provides methods for CRUD operations and business logic
class DomainService {
  /// Performs [operation] with given [parameters]
  /// 
  /// Returns [ResultType] on success
  /// 
  /// Throws [ExceptionType] when [condition] occurs
  Future<ResultType> performOperation(Parameters params) async {
    // Implementation
  }
}
```

## 4. PERFORMANCE OPTIMIZATIONS

### Widget Optimization Techniques
**Priority**: High

**Use ValueListenableBuilder for localized updates**:
```dart
// ❌ INEFFICIENT - Full widget rebuild
class _FormState extends State<Form> {
  final TextEditingController _controller = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      decoration: InputDecoration(
        suffixIcon: _controller.text.isNotEmpty
            ? IconButton(onPressed: _clearText, icon: Icon(Icons.clear))
            : null,
      ),
      onChanged: (value) {
        setState(() {}); // Rebuilds entire widget
      },
    );
  }
}

// ✅ OPTIMIZED - Localized rebuild
class _FormState extends State<Form> {
  final TextEditingController _controller = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      decoration: InputDecoration(
        suffixIcon: ValueListenableBuilder<TextEditingValue>(
          valueListenable: _controller,
          builder: (context, value, child) {
            return value.text.isNotEmpty
                ? IconButton(onPressed: _clearText, icon: Icon(Icons.clear))
                : const SizedBox.shrink();
          },
        ),
      ),
    );
  }
}
```

### Memory Management Rules
**Priority**: High

**Controller Disposal Template**:
```dart
class _ScreenState extends State<Screen> {
  final TextEditingController _textController = TextEditingController();
  final AnimationController _animController = AnimationController();
  final ScrollController _scrollController = ScrollController();
  final FocusNode _focusNode = FocusNode();
  
  @override
  void dispose() {
    _textController.dispose();
    _animController.dispose();
    _scrollController.dispose();
    _focusNode.dispose();
    super.dispose();
  }
}
```

**Async Operation Safety**:
```dart
class _ScreenState extends State<Screen> {
  bool _isLoading = false;

  Future<void> _performAsyncOperation() async {
    setState(() => _isLoading = true);
    
    try {
      await someAsyncOperation();
    } finally {
      if (mounted) {  // Check if widget is still mounted
        setState(() => _isLoading = false);
      }
    }
  }
}
```

### Const Widget Usage
**Priority**: Medium

```dart
// ✅ GOOD - Use const for static widgets
const SizedBox(height: 16),
const Spacer(),
const Divider(),

// ✅ GOOD - Use const constructors
const CustomWidget(
  title: 'Static Title',
  isEnabled: true,
)

// ❌ AVOID - Missing const when possible
SizedBox(height: 16),  // Should be const
CustomWidget(title: 'Static Title'),  // Should be const
```

## 5. STATE MANAGEMENT

### Recommended Pattern
**Priority**: High
**Pattern**: Local State + Service Layer

**Rationale**:
- Simple and maintainable for most applications
- Clear separation between UI state and business logic
- Easy to test and understand
- Scales well for small to medium applications

**Implementation Template**:
```dart
class _ScreenState extends State<Screen> {
  // UI state
  bool _isLoading = false;
  String? _errorMessage;
  List<DataModel> _items = [];
  
  // Service dependency
  final ApiService _apiService = ApiService();
  
  Future<void> _loadData() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    
    try {
      final items = await _apiService.fetchItems();
      setState(() {
        _items = items;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _isLoading = false;
      });
    }
  }
}
```

### Alternative Patterns
**For larger applications, consider**:
- **Provider**: For shared state across widgets
- **Riverpod**: For dependency injection and state management
- **Bloc**: For complex business logic and state transitions

## 6. REUSABLE COMPONENTS

### Navigation Header Template
```dart
/// Reusable header widget with navigation controls
class AppHeader extends StatelessWidget {
  final bool showBackButton;
  final bool showMenuButton;
  final String? title;
  final List<Widget>? actions;

  const AppHeader({
    super.key,
    this.showBackButton = true,
    this.showMenuButton = false,
    this.title,
    this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: showBackButton
          ? IconButton(
              onPressed: () => Navigator.pop(context),
              icon: Icon(Icons.arrow_back),
            )
          : showMenuButton
              ? IconButton(
                  onPressed: () => Scaffold.of(context).openDrawer(),
                  icon: Icon(Icons.menu),
                )
              : null,
      title: title != null ? Text(title!) : null,
      actions: actions,
    );
  }
}
```

### Loading Indicator Template
```dart
/// Reusable loading indicator with optional message
class LoadingIndicator extends StatelessWidget {
  final String? message;
  final bool showMessage;

  const LoadingIndicator({
    super.key,
    this.message,
    this.showMessage = true,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          if (showMessage && message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}
```

### Error Display Template
```dart
/// Reusable error display with retry functionality
class ErrorDisplay extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final String retryText;

  const ErrorDisplay({
    super.key,
    required this.message,
    this.onRetry,
    this.retryText = 'Retry',
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyLarge,
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: onRetry,
                child: Text(retryText),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
```

## 7. SERVICE LAYER PATTERNS

### API Service Template
```dart
class ApiService {
  static final ApiService _instance = ApiService._internal();
  factory ApiService() => _instance;
  ApiService._internal();

  final String _baseUrl = 'https://api.example.com';
  final Duration _timeout = Duration(seconds: 30);

  Future<List<T>> fetchList<T>(
    String endpoint,
    T Function(Map<String, dynamic>) fromJson,
  ) async {
    try {
      final response = await http.get(
        Uri.parse('$_baseUrl/$endpoint'),
      ).timeout(_timeout);

      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        return data.map((item) => fromJson(item)).toList();
      } else {
        throw ApiException('Failed to load data: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint("ApiService: Fetch error - $e");
      throw ApiException('Network error occurred');
    }
  }

  Future<T> create<T>(
    String endpoint,
    Map<String, dynamic> data,
    T Function(Map<String, dynamic>) fromJson,
  ) async {
    try {
      final response = await http.post(
        Uri.parse('$_baseUrl/$endpoint'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode(data),
      ).timeout(_timeout);

      if (response.statusCode == 201) {
        return fromJson(json.decode(response.body));
      } else {
        throw ApiException('Failed to create: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint("ApiService: Create error - $e");
      throw ApiException('Failed to create item');
    }
  }
}

class ApiException implements Exception {
  final String message;
  ApiException(this.message);
  
  @override
  String toString() => message;
}
```

### Navigation Service Template
```dart
class NavigationService {
  /// Navigate to new screen
  static Future<T?> push<T>(BuildContext context, Widget screen) {
    return Navigator.push<T>(
      context,
      MaterialPageRoute(builder: (context) => screen),
    );
  }
  
  /// Replace current screen
  static Future<T?> pushReplacement<T>(BuildContext context, Widget screen) {
    return Navigator.pushReplacement<T, void>(
      context,
      MaterialPageRoute(builder: (context) => screen),
    );
  }
  
  /// Clear stack and navigate
  static Future<T?> pushAndRemoveUntil<T>(
    BuildContext context, 
    Widget screen, {
    bool Function(Route<dynamic>)? predicate,
  }) {
    return Navigator.pushAndRemoveUntil<T>(
      context,
      MaterialPageRoute(builder: (context) => screen),
      predicate ?? (route) => false,
    );
  }
  
  /// Go back
  static void pop<T>(BuildContext context, [T? result]) {
    Navigator.pop(context, result);
  }
}
```

## 8. TESTING STANDARDS

### Widget Testing Template
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:myapp/widgets/custom_button.dart';

void main() {
  group('CustomButton Tests', () {
    testWidgets('displays text and responds to tap', (tester) async {
      bool tapped = false;
      
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CustomButton(
              onPressed: () => tapped = true,
              text: 'Test Button',
            ),
          ),
        ),
      );

      // Verify button is displayed
      expect(find.text('Test Button'), findsOneWidget);
      expect(find.byType(CustomButton), findsOneWidget);

      // Test tap functionality
      await tester.tap(find.byType(CustomButton));
      expect(tapped, isTrue);
    });
  });
}
```

### Service Testing Template
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:myapp/services/api_service.dart';

class MockHttpClient extends Mock implements http.Client {}

void main() {
  group('ApiService Tests', () {
    late ApiService apiService;
    late MockHttpClient mockClient;

    setUp(() {
      mockClient = MockHttpClient();
      apiService = ApiService(client: mockClient);
    });

    test('fetchItems returns list of items on success', () async {
      // Arrange
      when(mockClient.get(any)).thenAnswer(
        (_) async => http.Response('{"items": []}', 200),
      );

      // Act
      final result = await apiService.fetchItems();

      // Assert
      expect(result, isA<List<Item>>());
      verify(mockClient.get(any)).called(1);
    });
  });
}
```

## 9. ERROR HANDLING

### Exception Handling Pattern
```dart
// Custom exception classes
class AppException implements Exception {
  final String message;
  final String? code;
  
  AppException(this.message, {this.code});
  
  @override
  String toString() => message;
}

class NetworkException extends AppException {
  NetworkException(String message) : super(message, code: 'NETWORK_ERROR');
}

class ValidationException extends AppException {
  ValidationException(String message) : super(message, code: 'VALIDATION_ERROR');
}

// Service layer error handling
Future<Result> serviceMethod() async {
  try {
    // Business logic
    return result;
  } on SocketException {
    throw NetworkException('No internet connection');
  } on TimeoutException {
    throw NetworkException('Request timeout');
  } catch (e) {
    debugPrint("ServiceName: Method error - $e");
    throw AppException('An unexpected error occurred');
  }
}

// UI layer error handling
try {
  await _service.performOperation();
  // Show success feedback
} on NetworkException catch (e) {
  _showErrorDialog('Network Error', e.message);
} on ValidationException catch (e) {
  _showErrorDialog('Validation Error', e.message);
} on AppException catch (e) {
  _showErrorDialog('Error', e.message);
}
```

## 10. IMPLEMENTATION CHECKLIST

### For New Features:
- [ ] Follow folder structure conventions
- [ ] Use appropriate StatefulWidget vs StatelessWidget
- [ ] Add const constructors where possible
- [ ] Extract reusable widgets when used 2+ times
- [ ] Implement proper error handling
- [ ] Add controller disposal in dispose()
- [ ] Use centralized theme for styling
- [ ] Use NavigationService for navigation
- [ ] Document public APIs
- [ ] Add appropriate tests

### For Code Reviews:
- [ ] Check for const constructor usage
- [ ] Verify proper import organization
- [ ] Ensure consistent naming conventions
- [ ] Look for widget extraction opportunities
- [ ] Verify error handling implementation
- [ ] Check for memory leaks (controller disposal)
- [ ] Ensure theme consistency
- [ ] Verify navigation patterns
- [ ] Check for performance optimizations
- [ ] Validate test coverage

### Performance Checklist:
- [ ] Use ValueListenableBuilder for localized updates
- [ ] Dispose of all controllers and resources
- [ ] Use const widgets where possible
- [ ] Check mounted before setState in async operations
- [ ] Use stable keys for list items
- [ ] Minimize setState scope

---

*Universal Flutter/Dart standards - applicable to any application*
*Last updated: January 2025*