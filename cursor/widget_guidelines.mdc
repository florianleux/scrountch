# Widget Guidelines & UI Standards
*Universal Flutter widget patterns and UI component standards*

## 1. WIDGET HIERARCHY & COMPOSITION

### Screen Structure Template
**Priority**: High
**Applicability**: All Flutter screen widgets

**Standard Template**:
```dart
class FeatureScreen extends StatefulWidget {
  const FeatureScreen({super.key});

  @override
  State<FeatureScreen> createState() => _FeatureScreenState();
}

class _FeatureScreenState extends State<FeatureScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surface,
      body: Stack(
        children: [
          _buildBackground(),      // Layer 1: Background (optional)
          _buildContent(),         // Layer 2: Main content
        ],
      ),
    );
  }

  Widget _buildBackground() {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Theme.of(context).colorScheme.primary.withOpacity(0.1),
            Theme.of(context).colorScheme.surface,
          ],
        ),
      ),
    );
  }

  Widget _buildContent() {
    return SafeArea(
      child: Column(
        children: [
          _buildHeader(),          // Consistent navigation
          Expanded(
            child: _buildBody(),   // Feature-specific content
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return const AppHeader();
  }

  Widget _buildBody() {
    // Feature-specific implementation
    return Container();
  }
}
```

### Widget Composition Rules
**Priority**: High

**Rule 1**: Single Responsibility Principle
```dart
// ❌ BAD - Widget doing too many things
class ComplexUserWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Avatar logic
        // Name display logic
        // Status indicator logic
        // Action buttons logic
        // Statistics display logic
      ],
    );
  }
}

// ✅ GOOD - Composed of focused widgets
class UserProfileWidget extends StatelessWidget {
  final User user;
  
  const UserProfileWidget({super.key, required this.user});
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        UserAvatar(user: user),
        UserNameDisplay(user: user),
        UserStatusIndicator(user: user),
        UserActionButtons(user: user),
        UserStatistics(user: user),
      ],
    );
  }
}
```

**Rule 2**: Composition over Inheritance
```dart
// ✅ GOOD - Compose reusable widgets
class ActionButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final IconData? icon;
  final ButtonStyle? style;

  const ActionButton({
    super.key,
    required this.text,
    this.onPressed,
    this.icon,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      style: style ?? Theme.of(context).elevatedButtonTheme.style,
      child: icon != null
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon),
                const SizedBox(width: 8),
                Text(text),
              ],
            )
          : Text(text),
    );
  }
}
```

## 2. REUSABLE WIDGET PATTERNS

### Header Component Pattern
**Priority**: High
**Use Case**: Consistent navigation across screens

**Generic Header Template**:
```dart
class AppHeader extends StatelessWidget {
  final String? title;
  final bool showBackButton;
  final bool showMenuButton;
  final List<Widget>? actions;
  final VoidCallback? onBackPressed;
  final VoidCallback? onMenuPressed;

  const AppHeader({
    super.key,
    this.title,
    this.showBackButton = true,
    this.showMenuButton = false,
    this.actions,
    this.onBackPressed,
    this.onMenuPressed,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: title != null ? Text(title!) : null,
      leading: _buildLeading(context),
      actions: actions,
      backgroundColor: Theme.of(context).colorScheme.surface,
      foregroundColor: Theme.of(context).colorScheme.onSurface,
      elevation: 0,
    );
  }

  Widget? _buildLeading(BuildContext context) {
    if (showBackButton) {
      return IconButton(
        onPressed: onBackPressed ?? () => Navigator.pop(context),
        icon: const Icon(Icons.arrow_back),
      );
    }
    
    if (showMenuButton) {
      return IconButton(
        onPressed: onMenuPressed ?? () => Scaffold.of(context).openDrawer(),
        icon: const Icon(Icons.menu),
      );
    }
    
    return null;
  }
}

// Usage examples:
const AppHeader(title: 'Profile'),
const AppHeader(showBackButton: false, showMenuButton: true),
AppHeader(
  title: 'Settings',
  actions: [
    IconButton(onPressed: _save, icon: Icon(Icons.save)),
  ],
),
```

### Loading States Pattern
**Priority**: High
**Use Case**: Consistent loading indicators across app

**Loading Widget Templates**:
```dart
/// Simple loading indicator
class LoadingIndicator extends StatelessWidget {
  final String? message;
  final double? size;

  const LoadingIndicator({
    super.key,
    this.message,
    this.size,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(
            width: size ?? 40,
            height: size ?? 40,
            child: CircularProgressIndicator(
              strokeWidth: 3,
              valueColor: AlwaysStoppedAnimation<Color>(
                Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}

/// Loading overlay for buttons
class LoadingButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final IconData? icon;

  const LoadingButton({
    super.key,
    required this.text,
    this.onPressed,
    this.isLoading = false,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      child: isLoading
          ? const SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          : icon != null
              ? Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(icon),
                    const SizedBox(width: 8),
                    Text(text),
                  ],
                )
              : Text(text),
    );
  }
}
```

### Error Display Pattern
**Priority**: High
**Use Case**: Consistent error handling across app

**Error Widget Templates**:
```dart
/// Generic error display widget
class ErrorDisplay extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final String retryText;
  final IconData? icon;

  const ErrorDisplay({
    super.key,
    required this.message,
    this.onRetry,
    this.retryText = 'Retry',
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon ?? Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                color: Theme.of(context).colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: onRetry,
                child: Text(retryText),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Error banner for inline errors
class ErrorBanner extends StatelessWidget {
  final String message;
  final VoidCallback? onDismiss;
  final VoidCallback? onRetry;

  const ErrorBanner({
    super.key,
    required this.message,
    this.onDismiss,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          Icon(
            Icons.error_outline,
            color: Theme.of(context).colorScheme.error,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
            ),
          ),
          if (onRetry != null) ...[
            TextButton(
              onPressed: onRetry,
              child: Text('Retry'),
            ),
          ],
          if (onDismiss != null) ...[
            IconButton(
              onPressed: onDismiss,
              icon: Icon(Icons.close),
              iconSize: 20,
            ),
          ],
        ],
      ),
    );
  }
}
```

### Empty State Pattern
**Priority**: Medium
**Use Case**: When lists or content areas are empty

```dart
class EmptyState extends StatelessWidget {
  final String title;
  final String? subtitle;
  final IconData? icon;
  final String? actionText;
  final VoidCallback? onAction;

  const EmptyState({
    super.key,
    required this.title,
    this.subtitle,
    this.icon,
    this.actionText,
    this.onAction,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                size: 80,
                color: Theme.of(context).colorScheme.outline,
              ),
              const SizedBox(height: 24),
            ],
            Text(
              title,
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurface,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle != null) ...[
              const SizedBox(height: 8),
              Text(
                subtitle!,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (actionText != null && onAction != null) ...[
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: onAction,
                child: Text(actionText!),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
```

## 3. INPUT WIDGET PATTERNS

### Form Field Pattern
**Priority**: High
**Use Case**: Consistent form inputs across app

**Text Field Template**:
```dart
class AppTextField extends StatelessWidget {
  final TextEditingController? controller;
  final String? labelText;
  final String? hintText;
  final String? helperText;
  final int? maxLength;
  final int? maxLines;
  final String? Function(String?)? validator;
  final TextInputAction? textInputAction;
  final TextInputType? keyboardType;
  final void Function(String)? onChanged;
  final void Function(String)? onFieldSubmitted;
  final bool obscureText;
  final Widget? prefixIcon;
  final Widget? suffixIcon;
  final bool enabled;
  final bool readOnly;

  const AppTextField({
    super.key,
    this.controller,
    this.labelText,
    this.hintText,
    this.helperText,
    this.maxLength,
    this.maxLines = 1,
    this.validator,
    this.textInputAction,
    this.keyboardType,
    this.onChanged,
    this.onFieldSubmitted,
    this.obscureText = false,
    this.prefixIcon,
    this.suffixIcon,
    this.enabled = true,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      maxLength: maxLength,
      maxLines: maxLines,
      validator: validator,
      textInputAction: textInputAction,
      keyboardType: keyboardType,
      onChanged: onChanged,
      onFieldSubmitted: onFieldSubmitted,
      obscureText: obscureText,
      enabled: enabled,
      readOnly: readOnly,
      decoration: InputDecoration(
        labelText: labelText,
        hintText: hintText,
        helperText: helperText,
        prefixIcon: prefixIcon,
        suffixIcon: suffixIcon,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }
}

// Usage examples:
AppTextField(
  controller: _nameController,
  labelText: 'Full Name',
  validator: (value) => value?.isEmpty == true ? 'Name is required' : null,
)

AppTextField(
  controller: _emailController,
  labelText: 'Email',
  keyboardType: TextInputType.emailAddress,
  prefixIcon: Icon(Icons.email),
  validator: _validateEmail,
)

AppTextField(
  controller: _passwordController,
  labelText: 'Password',
  obscureText: true,
  suffixIcon: IconButton(
    onPressed: _togglePasswordVisibility,
    icon: Icon(_showPassword ? Icons.visibility_off : Icons.visibility),
  ),
)
```

### Dropdown Pattern
**Priority**: High
**Use Case**: Consistent dropdown selections

**Dropdown Templates**:
```dart
class AppDropdown<T> extends StatelessWidget {
  final T? value;
  final String? labelText;
  final String? hintText;
  final List<DropdownMenuItem<T>> items;
  final void Function(T?)? onChanged;
  final String? Function(T?)? validator;
  final bool isExpanded;
  final Widget? prefixIcon;

  const AppDropdown({
    super.key,
    this.value,
    this.labelText,
    this.hintText,
    required this.items,
    this.onChanged,
    this.validator,
    this.isExpanded = true,
    this.prefixIcon,
  });

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<T>(
      value: value,
      items: items,
      onChanged: onChanged,
      validator: validator,
      isExpanded: isExpanded,
      decoration: InputDecoration(
        labelText: labelText,
        hintText: hintText,
        prefixIcon: prefixIcon,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    );
  }
}

// Searchable dropdown for large lists
class SearchableDropdown<T> extends StatefulWidget {
  final T? value;
  final String? labelText;
  final List<T> items;
  final String Function(T) itemLabel;
  final void Function(T?)? onChanged;
  final String? Function(T?)? validator;

  const SearchableDropdown({
    super.key,
    this.value,
    this.labelText,
    required this.items,
    required this.itemLabel,
    this.onChanged,
    this.validator,
  });

  @override
  State<SearchableDropdown<T>> createState() => _SearchableDropdownState<T>();
}

class _SearchableDropdownState<T> extends State<SearchableDropdown<T>> {
  final TextEditingController _searchController = TextEditingController();
  List<T> _filteredItems = [];

  @override
  void initState() {
    super.initState();
    _filteredItems = widget.items;
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _filterItems(String query) {
    setState(() {
      _filteredItems = widget.items
          .where((item) => widget.itemLabel(item)
              .toLowerCase()
              .contains(query.toLowerCase()))
          .toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.labelText != null) ...[
          Text(
            widget.labelText!,
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const SizedBox(height: 8),
        ],
        TextField(
          controller: _searchController,
          decoration: InputDecoration(
            hintText: 'Search...',
            prefixIcon: Icon(Icons.search),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
          onChanged: _filterItems,
        ),
        const SizedBox(height: 8),
        Container(
          height: 200,
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).dividerColor),
            borderRadius: BorderRadius.circular(8),
          ),
          child: ListView.builder(
            itemCount: _filteredItems.length,
            itemBuilder: (context, index) {
              final item = _filteredItems[index];
              return ListTile(
                title: Text(widget.itemLabel(item)),
                selected: widget.value == item,
                onTap: () {
                  widget.onChanged?.call(item);
                  _searchController.clear();
                  _filteredItems = widget.items;
                },
              );
            },
          ),
        ),
      ],
    );
  }
}
```

### Switch and Checkbox Patterns
**Priority**: Medium

```dart
class AppSwitch extends StatelessWidget {
  final bool value;
  final void Function(bool)? onChanged;
  final String? title;
  final String? subtitle;

  const AppSwitch({
    super.key,
    required this.value,
    this.onChanged,
    this.title,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return SwitchListTile(
      value: value,
      onChanged: onChanged,
      title: title != null ? Text(title!) : null,
      subtitle: subtitle != null ? Text(subtitle!) : null,
      contentPadding: EdgeInsets.zero,
    );
  }
}

class AppCheckbox extends StatelessWidget {
  final bool value;
  final void Function(bool?)? onChanged;
  final String? title;
  final String? subtitle;

  const AppCheckbox({
    super.key,
    required this.value,
    this.onChanged,
    this.title,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return CheckboxListTile(
      value: value,
      onChanged: onChanged,
      title: title != null ? Text(title!) : null,
      subtitle: subtitle != null ? Text(subtitle!) : null,
      contentPadding: EdgeInsets.zero,
      controlAffinity: ListTileControlAffinity.leading,
    );
  }
}
```

## 4. LIST & CARD PATTERNS

### List Item Pattern
**Priority**: High
**Use Case**: Consistent list item display

```dart
class AppListItem extends StatelessWidget {
  final String title;
  final String? subtitle;
  final Widget? leading;
  final Widget? trailing;
  final VoidCallback? onTap;
  final VoidCallback? onLongPress;
  final bool selected;
  final EdgeInsetsGeometry? contentPadding;

  const AppListItem({
    super.key,
    required this.title,
    this.subtitle,
    this.leading,
    this.trailing,
    this.onTap,
    this.onLongPress,
    this.selected = false,
    this.contentPadding,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(
        title,
        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
          fontWeight: selected ? FontWeight.bold : FontWeight.normal,
        ),
        maxLines: 2,
        overflow: TextOverflow.ellipsis,
      ),
      subtitle: subtitle != null
          ? Text(
              subtitle!,
              style: Theme.of(context).textTheme.bodyMedium,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            )
          : null,
      leading: leading,
      trailing: trailing ?? (onTap != null ? Icon(Icons.chevron_right) : null),
      onTap: onTap,
      onLongPress: onLongPress,
      selected: selected,
      contentPadding: contentPadding ?? EdgeInsets.symmetric(horizontal: 16, vertical: 8),
    );
  }
}
```

### Card Pattern
**Priority**: High
**Use Case**: Consistent card layouts

```dart
class AppCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry? margin;
  final EdgeInsetsGeometry? padding;
  final VoidCallback? onTap;
  final double? elevation;
  final Color? color;

  const AppCard({
    super.key,
    required this.child,
    this.margin,
    this.padding,
    this.onTap,
    this.elevation,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    Widget card = Card(
      margin: margin ?? EdgeInsets.all(8),
      elevation: elevation ?? 2,
      color: color,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: padding ?? EdgeInsets.all(16),
        child: child,
      ),
    );

    if (onTap != null) {
      card = InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: card,
      );
    }

    return card;
  }
}

// Usage examples:
AppCard(
  child: Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Text('Card Title', style: Theme.of(context).textTheme.headlineSmall),
      SizedBox(height: 8),
      Text('Card content goes here...'),
    ],
  ),
  onTap: () => print('Card tapped'),
)
```

## 5. DIALOG & MODAL PATTERNS

### Dialog Templates
**Priority**: High

```dart
class AppDialog extends StatelessWidget {
  final String title;
  final Widget content;
  final List<Widget>? actions;
  final bool barrierDismissible;

  const AppDialog({
    super.key,
    required this.title,
    required this.content,
    this.actions,
    this.barrierDismissible = true,
  });

  static Future<T?> show<T>(
    BuildContext context, {
    required String title,
    required Widget content,
    List<Widget>? actions,
    bool barrierDismissible = true,
  }) {
    return showDialog<T>(
      context: context,
      barrierDismissible: barrierDismissible,
      builder: (context) => AppDialog(
        title: title,
        content: content,
        actions: actions,
        barrierDismissible: barrierDismissible,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(title),
      content: content,
      actions: actions,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
    );
  }
}

// Confirmation dialog
class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String confirmText;
  final String cancelText;
  final VoidCallback onConfirm;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.confirmText = 'Confirm',
    this.cancelText = 'Cancel',
    required this.onConfirm,
  });

  static Future<bool?> show(
    BuildContext context, {
    required String title,
    required String message,
    String confirmText = 'Confirm',
    String cancelText = 'Cancel',
    required VoidCallback onConfirm,
  }) {
    return showDialog<bool>(
      context: context,
      builder: (context) => ConfirmationDialog(
        title: title,
        message: message,
        confirmText: confirmText,
        cancelText: cancelText,
        onConfirm: onConfirm,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText),
        ),
        ElevatedButton(
          onPressed: () {
            onConfirm();
            Navigator.of(context).pop(true);
          },
          child: Text(confirmText),
        ),
      ],
    );
  }
}

// Usage:
final confirmed = await ConfirmationDialog.show(
  context,
  title: 'Delete Item',
  message: 'Are you sure you want to delete this item?',
  onConfirm: () => _deleteItem(),
);
```

### Bottom Sheet Pattern
**Priority**: Medium

```dart
class AppBottomSheet extends StatelessWidget {
  final String? title;
  final Widget child;
  final bool showDragHandle;
  final bool isScrollControlled;

  const AppBottomSheet({
    super.key,
    this.title,
    required this.child,
    this.showDragHandle = true,
    this.isScrollControlled = false,
  });

  static Future<T?> show<T>(
    BuildContext context, {
    String? title,
    required Widget child,
    bool showDragHandle = true,
    bool isScrollControlled = false,
  }) {
    return showModalBottomSheet<T>(
      context: context,
      isScrollControlled: isScrollControlled,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) => AppBottomSheet(
        title: title,
        child: child,
        showDragHandle: showDragHandle,
        isScrollControlled: isScrollControlled,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showDragHandle) ...[
            Container(
              width: 40,
              height: 4,
              margin: EdgeInsets.symmetric(vertical: 12),
              decoration: BoxDecoration(
                color: Theme.of(context).dividerColor,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ],
          if (title != null) ...[
            Padding(
              padding: EdgeInsets.symmetric(horizontal: 16),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      title!,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                  ),
                  IconButton(
                    onPressed: () => Navigator.pop(context),
                    icon: Icon(Icons.close),
                  ),
                ],
              ),
            ),
            Divider(),
          ],
          Flexible(child: child),
        ],
      ),
    );
  }
}
```

## 6. RESPONSIVE DESIGN PATTERNS

### Breakpoint System
**Priority**: Medium
**Use Case**: Responsive layouts across different screen sizes

```dart
class Breakpoints {
  static const double mobile = 600;
  static const double tablet = 900;
  static const double desktop = 1200;

  static bool isMobile(BuildContext context) =>
      MediaQuery.of(context).size.width < mobile;

  static bool isTablet(BuildContext context) =>
      MediaQuery.of(context).size.width >= mobile &&
      MediaQuery.of(context).size.width < desktop;

  static bool isDesktop(BuildContext context) =>
      MediaQuery.of(context).size.width >= desktop;
}

class ResponsiveBuilder extends StatelessWidget {
  final Widget mobile;
  final Widget? tablet;
  final Widget? desktop;

  const ResponsiveBuilder({
    super.key,
    required this.mobile,
    this.tablet,
    this.desktop,
  });

  @override
  Widget build(BuildContext context) {
    if (Breakpoints.isDesktop(context) && desktop != null) {
      return desktop!;
    }
    if (Breakpoints.isTablet(context) && tablet != null) {
      return tablet!;
    }
    return mobile;
  }
}

// Usage:
ResponsiveBuilder(
  mobile: Column(children: widgets),
  tablet: Row(children: widgets),
  desktop: GridView.count(crossAxisCount: 3, children: widgets),
)
```

### Adaptive Layouts
**Priority**: Medium

```dart
class AdaptiveContainer extends StatelessWidget {
  final Widget child;
  final double? maxWidth;

  const AdaptiveContainer({
    super.key,
    required this.child,
    this.maxWidth,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        width: double.infinity,
        constraints: BoxConstraints(
          maxWidth: maxWidth ?? 
              (Breakpoints.isMobile(context) ? double.infinity : 800),
        ),
        child: child,
      ),
    );
  }
}

class AdaptivePadding extends StatelessWidget {
  final Widget child;

  const AdaptivePadding({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    final padding = Breakpoints.isMobile(context) ? 16.0 : 32.0;
    return Padding(
      padding: EdgeInsets.all(padding),
      child: child,
    );
  }
}
```

## 7. PERFORMANCE OPTIMIZATION PATTERNS

### Const Widget Usage
**Priority**: High

```dart
// ✅ GOOD - Use const for static widgets
const SizedBox(height: 16),
const Divider(),
const CircularProgressIndicator(),

// ✅ GOOD - Const constructors
const AppCard(
  child: Text('Static content'),
)

// ✅ GOOD - Const in lists
Column(
  children: [
    const AppHeader(title: 'Static Title'),
    Expanded(child: _buildDynamicContent()),
    const SizedBox(height: 16),
  ],
)
```

### ValueListenableBuilder Optimization
**Priority**: High

```dart
class OptimizedWidget extends StatefulWidget {
  @override
  State<OptimizedWidget> createState() => _OptimizedWidgetState();
}

class _OptimizedWidgetState extends State<OptimizedWidget> {
  final ValueNotifier<int> _counter = ValueNotifier(0);
  
  @override
  void dispose() {
    _counter.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Static part - never rebuilds
        const Text('Counter App'),
        
        // Dynamic part - only rebuilds when counter changes
        ValueListenableBuilder<int>(
          valueListenable: _counter,
          builder: (context, count, child) {
            return Text('Count: $count');
          },
        ),
        
        // Static part - never rebuilds
        ElevatedButton(
          onPressed: () => _counter.value++,
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

### List Performance
**Priority**: High

```dart
// For large lists
class OptimizedListView extends StatelessWidget {
  final List<Item> items;
  final void Function(Item) onItemTap;

  const OptimizedListView({
    super.key,
    required this.items,
    required this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];
        return AppListItem(
          key: ValueKey(item.id), // Stable key for performance
          title: item.title,
          subtitle: item.subtitle,
          onTap: () => onItemTap(item),
        );
      },
    );
  }
}

// For small lists with complex items
class OptimizedColumn extends StatelessWidget {
  final List<Item> items;

  const OptimizedColumn({super.key, required this.items});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: items.map((item) => ItemWidget(
        key: ValueKey(item.id),
        item: item,
      )).toList(),
    );
  }
}
```

---

## WIDGET CHECKLIST

### For New Widgets:
- [ ] Use const constructor when possible
- [ ] Add proper key parameter (super.key)
- [ ] Handle null safety appropriately
- [ ] Follow naming conventions (PascalCase)
- [ ] Use theme values instead of hardcoded styles
- [ ] Add documentation comments
- [ ] Dispose of resources in StatefulWidget
- [ ] Use ValueListenableBuilder for localized updates
- [ ] Handle different screen sizes appropriately
- [ ] Add semantic labels for accessibility

### For Widget Composition:
- [ ] Single responsibility principle
- [ ] Compose instead of inherit
- [ ] Extract reusable components (2+ usage rule)
- [ ] Use consistent spacing and sizing
- [ ] Follow established visual hierarchy
- [ ] Maintain consistent interaction patterns
- [ ] Use proper key values for list items
- [ ] Handle loading, error, and empty states
- [ ] Test widget behavior across different screen sizes
- [ ] Ensure proper color contrast for accessibility

### Performance Checklist:
- [ ] Use const widgets where possible
- [ ] Implement ValueListenableBuilder for localized updates
- [ ] Use stable keys for list items
- [ ] Avoid creating widgets in build methods unnecessarily
- [ ] Cache expensive computations
- [ ] Dispose of controllers and notifiers
- [ ] Use ListView.builder for large lists
- [ ] Minimize widget tree depth

---

*Universal Flutter widget patterns and UI standards*
*Last updated: January 2025*